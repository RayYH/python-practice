"""
'Cell' objects are used to implement variables referenced by multiple scopes.
For each such variable, a cell object is created to store the value; the
local variables of each stack frame that references the value contains
a reference to the cells from outer scopes which also use that
variable. When the value is accessed, the value contained in
the cell is used instead of the cell object itself. This
de-referencing of the cell object requires support from
the generated byte-code; these are not automatically
de-referenced when accessed. Cell objects are not
likely to be useful elsewhere.
"""
from src.helper.disable_inspection import do_whatever


def is_cell(obj):
    return '{}'.format(type(obj)) == "<class 'cell'>"


def is_tuple(obj):
    return '{}'.format(type(obj)) == "<class 'tuple'>"


def foo(x):
    def bar(y):
        q = 10

        def baz(z):
            return x + y + q + z

        return baz

    return bar


def test_magic_closure_property():
    assert not is_cell(foo.__closure__)

    bar = foo(10)
    assert is_tuple(bar.__closure__)
    assert is_cell(bar.__closure__[0])
    assert bar.__closure__[0].cell_contents == 10  # x

    baz = bar(20)
    assert is_tuple(baz.__closure__)
    for i in range(0, len(baz.__closure__)):
        assert is_cell(baz.__closure__[i])
    assert baz.__closure__[0].cell_contents == 10  # x
    assert baz.__closure__[1].cell_contents == 10  # q
    assert baz.__closure__[2].cell_contents == 20  # y

    assert foo(10)(20)(30) == 70


def outer(x):
    do_whatever(x)

    def inner():
        pass

    return inner


def test_functions_without_free_variables_are_not_closures():
    f = outer(10)
    assert not f.__closure__


global_var = 100
